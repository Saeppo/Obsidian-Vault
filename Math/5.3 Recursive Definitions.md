Rabbits on an island

A pair of newborn rabbits are put on a rabbit-deserted island
From the age of two months, a pair of rabbits produce another pair of rabbits every month no rabbits die.

At the begninning of the n'th month there are f_n (fibunati) rabbits pairs on the island

$$
n:0,1,2,3,4,5,6,7,8,9,10,11,12...
$$
$$
f_{n}:0,1,1,2,3,5,8,13,21,34,55,89,144
$$
**Example for one-step recursion:**
$$
\begin{cases} a_0 = 2 \\[1mm] a_n = 6 a_{n-1}, n \ge 1 \end{cases}​$$
**Example for two-step recursion (Fibonacci-type):**

$$\begin{cases} F_0 = 0, \; F_1 = 1 \\[1mm] F_n = F_{n-1} + F_{n-2}, \; n \ge 2 \end{cases}$$
### Fibonacci numbers
$$
f_{0}=0 \newline \enspace
f_{1}=1
$$
$$
f_{n}=f_{n-2}+f_{n-1}, n \geq 2
$$
## Full Binary trees
![[Pasted image 20251117142625.png]]
Recursive definition of full binary tree

### Basis skridt
Vi har et FBT (Full binary tree)
### Recursive step
hvis $T_{1}$ og $T_{2}$ er FBTs så er
Recursive Definition of full binary tree (FBTs)
![[Pasted image 20251117143719.png]]
### example
![[Pasted image 20251117142821.png]]
Første er et FBT, da det har "The Root" og 2 leaves
Anden er et FBT som har 3 blade og 1 barn.
Tredje har ikke 0 eller 2 børn, som nævnt tidligere. Venstre undertre er tomt.

![[Pasted image 20251117143708.png]]
Basis skridt
$S_{1}$ Indeholder det træ vi havde i basis skridtet.
$S_{i}$ Vi kan tage fra root og bygge flere subtrees på.
$$$S_{2} = \{*, \text{Træ med root og 2 leaves}\}$$
$$$S_{3} = \{*, \text{1 Root 2 leaves, 1 Root 1 barn og 3 blade (højre), 1 root og 3 blade (venstre), 1 rod 2 børn og 4 blade}\}$$
## Structural induction
![[Pasted image 20251117143647.png]]
![[Pasted image 20251117143657.png]]
![[Pasted image 20251117143808.png]]
Undertræer har højde 0. Deres forældre har minimum højde 1. Den næste har 1 plus maks af dets undertræers højde, så 2. og ved roden bliver det 1+2 = 3. Så det fulde træ har højden 3.

Leaves 0
Børn nederst, er højde 1
Barn øverst, højde 2
Roden, tager man børnen og lægger sammen, så 3.

Højde 1 har 3 knuder ![[Pasted image 20251117144103.png]]
Højde 2 har her 5 knuder, kan udbygge til 7 knuder ![[Pasted image 20251117144116.png]]

$h = 0, \text{Giver 1 knude}$
$h = 1, \text{Giver 3 knuder}$
$h = 2, \text{Giver 7 knuder}$
$h = 3, \text{Giver 15 knuder}$
$$
n_{h}=2*n_{h-1}+1
$$
$$
n_{h}=2^{h+1}-1
$$
![[Pasted image 20251117144409.png]]
## Proof by structural induction
![[Pasted image 20251117144605.png]]
![[Pasted image 20251117144614.png]]
### Basis: 
En knude *
$n=1, h=1$
$2^{h+1}-1=2^{0+1}-1=2^{1}-1=1 = n$

### Induction Hypothesis:
$n(T) \leq 2^{h(T)+1}-1$, for all $T \in S_{i}$

### Inductive Step:
$T \in S_{i+1}-S_{i}$
![[Pasted image 20251117144947.png]]
Hvis det fulde træ er i $S_{i}$ så må undertræerne også være i $S_{i}$

$$n(T)=n(T_{1})+n(T_{2})+1$$
$T_{1} \space og \space T_{2} \space tilhøre \space S_{i}, \text{så dem ved vi noget om}$
$$
\leq 2^{h(T_{1})+1} + 2^{h(T_{2})+1}-1 \text{, Ifølge induktions antagelsen}
$$$$
\leq 2^{h(T)}+ 2^{h(T)}-1
$$
Vi har 2 h(T)
$$
= 2*2^{h(T)}-1
$$
$$
= 2^{h(T)+1}-1
$$

## Ackermann's Function

Ackermann's function is a recursive function that grows extremely rapidly and is frequently used as an example of a function that is computable but not primitive recursive.

**Definition:**

The Ackermann function A(m,n)A(m, n)A(m,n) is defined as follows:

$$A(m, n) = 
\begin{cases} 
n + 1 & \text{if } m = 0 \\
A(m - 1, 1) & \text{if } m > 0 \text{ and } n = 0 \\
A(m - 1, A(m, n - 1)) & \text{if } m > 0 \text{ and } n > 0
\end{cases}$$
Man tager sit tal A(1,0), sætter ind. m > 0 og n = 0, så derfor den i midten. det vil sige m-1 = 0 og ,1 bagefter, så A(0,1), så er m=0 og derfor n+1 = 1+1=2
**Key Characteristics:**

- The function is defined using three mutually recursive cases
- The recursive definition involves calling the function with the same nnn value but a decremented mmm value, creating a highly nested recursion

**Small Values:**

| $\frac{m}{n}$ | 0   | 1     | 2                       | 3   |
| ------------- | --- | ----- | ----------------------- | --- |
| 0             | 1   | 2     | 3                       | 4   |
| 1             | 2   | 3     | 4                       | 5   |
| 2             | 3   | 5     | 7                       | 29  |
| 3             | 5   | 13    | 61                      | 233 |
| 4             | 13  | 65533 | Extremely large numbers |     |

**Behavior by Fixed Values of m:**

- $A(0,n)=n+1A(0, n) = n + 1A(0,n)=n+1$ (successor function)
- $A(1,n)=n+2A(1, n) = n + 2A(1,n)=n+2$(repeated successor)
- $A(2,n)=2n+3A(2, n) = 2n + 3A(2,n)=2n+3$ (multiplication)
- $A(3,n)=2↑↑(n+3)−3A(3, n) = 2↑↑(n + 3) - 3A(3,n)=2↑↑(n+3)−3$ (tetration, repeated exponentiation)
- $A(4,n)A(4, n)A(4,n)$ grows even faster, producing numbers vastly larger than tetration
### __Iterated Logarithm (log_ n)_*

The iterated logarithm, denoted log* n, counts the number of times the logarithm function must be iteratively applied to n before the result is less than or equal to 1.

**Definition:**


$$log* n = 0 if n ≤ 1$$
$$log* n = 1 + log*(log n) if n > 1$$
**Process:** Repeatedly apply the logarithm until the result ≤ 1, and count the number of applications.

**Examples:**

- $log* 2 = 1 (log 2 = 1 ≤ 1)$
- $log* 4 = 2 (log 4 = 2, log 2 = 1 ≤ 1)$
- $log* 16 = 4 (log 16 = 4, log 4 = 2, log 2 = 1 ≤ 1)$
- $log* 65536 = 6 (log 65536 = 16, log 16 = 4, log 4 = 2, log 2 = 1 ≤ 1)$

**Key Property:** log* n grows extremely slowly. Even for enormous values like 2²⁰⁴⁸, log* n = 7.